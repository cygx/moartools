#!/usr/bin/env perl6
# Copyright 2016 cygx <cygx@cpan.org>
# Distributed under the Boost Software License, Version 1.0

use v6;

class Op { ... }

sub op(*@signature, :$suffix) {
    Op.new(:@signature, :$suffix);
}

my \OPS = {
    chars       => op(<I S>),
    close       => op(<O>, :suffix<fh>),
    dec         => op(<I>, :suffix<i>),
    exit        => op(<I>),
    open        => op(<O S S>, :suffix<fh>),
    print       => op(<S>),
    readline    => op(<S O>, :suffix<fh>),
    say         => op(<S>),
}

my \MULTIOPS = {
    return => %(
        op(<I>, :suffix<i>).pair,
        op(<N>, :suffix<n>).pair,
        op(<S>, :suffix<s>).pair,
        op(<O>, :suffix<o>).pair,
        op().pair,
    )
}

my @types = <int num str obj>;
my @ops = OPS.keys;
my @multiops = MULTIOPS.keys;

my $lines;
my $line;
my $n;

my @scopes;
my $blocks;

class MoarTLException is Exception {
    has $.msg;
    has $.n;
    has $.line;
    method new($msg) { self.bless(:$msg, :$n, :$line) }
    method message { "{$.type}: $!msg\n[$!n] $!line" }
    method type { !!! }
}

class X::MoarTL::Panic is MoarTLException { method type { 'panic' } }
class X::MoarTL::Syntax is MoarTLException { method type { 'syntax error' } }
class X::MoarTL::Lexical is MoarTLException { method type { 'lexical error' } }

multi bailout($msg = '?') is hidden-from-backtrace {
    die X::MoarTL::Panic.new($msg);
}

multi bailout($msg = '?', :$syn!) is hidden-from-backtrace {
    die X::MoarTL::Syntax.new($msg);
}

multi bailout($msg = '?', :$lex!) is hidden-from-backtrace {
    die X::MoarTL::Lexical.new($msg);
}

class Block { ... }
class Var { ... }
class Tmp { ... }
class IVal { ... }
class SVal { ... }
class Noop { ... }
class Const { ... }
class Cast { ... }

sub next-line {
    my $next := $lines.pull-one;
    return $next if $next =:= IterationEnd;
    ++$n;
    $line = $next.trim;
}

sub lookup($name) {
    for @scopes {
        return .{$name}
            if .{$name}:exists;
    }

    Nil;
}

sub find_multi($op, $argsig) {
    my %multi := MULTIOPS{$op};
    %multi{$argsig} // do {
        my @candis = %multi.keys.grep: {
            .lc eq $argsig.lc and [&&] .comb Zle $argsig.comb;
        }

        if @candis == 0 { bailout 'wrong operands' }
        elsif @candis > 1 { bailout 'ambiguous operands' }

        %multi{@candis[0]};
    }
}

sub block($name) { ... }

sub parse($src --> Nil) {
    put ".file $src";
    put ".hll tiny";

    my %*scope;

    $n = 0;
    $lines := $src.IO.lines(:close).iterator();
    @scopes := [ %*scope ];

    while ($_ := next-line) !=:= IterationEnd { /^[
        || [\#|$]
        || (:s fn (\w+)${ put ".frame $0" })
        || (:s ld (\w+)'()' '{'${
            my $name = ~$0;
            put ".frame $name";
            put ".set load";
            $blocks = 0;
            block $name;
        })
        || (:s fn (\w+)'()' '{'${
            my $name = ~$0;
            put ".frame $name";
            $blocks = 0;
            block $name;
        })
        || {bailout}
    ]/ }
}

sub iv(Int() $i) { IVal.new(:$i) }
sub sv(Str() $s) { SVal.new(:$s) }
sub const($value) { Const.new(:$value) }
sub cast($expr, $type) { Cast.new(:$expr, :$type) }

sub sig($_) {
    when 'int' { 'i' }
    when 'str' { 's' }
}

sub extsig($_) {
    when 'int' { 'i64' }
    when 'str' { 's' }
}

sub argsig(*@args) {
    @args>>.sig.join;
}

my token subexpression {
    | ((\w+) <?{ lookup(~$0) ~~ Var }> { push @*made, lookup(~$0) })
    | ((\d+) { push @*made, iv(~$0) })
    | ("'" (<-[']>*) "'" { push @*made, sv(~$0) })
}

my token expression {
    | ((str) '(' <&subexpression> ')' { push @*made, cast(@*made.pop, ~$0) })
    | <&subexpression>
}

sub is-label($name) {
    lookup($name) ~~ Block || bailout :lex, "unknown label '$name'";
}

sub block($blockname) {
    my %*scope;
    my $*block = Block.new(name => $blockname, id => $blocks++);
    %*scope{$blockname} = $*block;
    @scopes.unshift(%*scope);
    LEAVE @scopes.shift;

    put ".{$*block.bra}:";

    my @*made;
    while ($_ := next-line) !=:= IterationEnd { /^[
        | [\#|$]
        | (:s '.'(\w+) '{'${ block ~$0 })
        | ('}' ${
            put ".{$*block.ket}:";
            return;
        })
        | (:s (@types) (\w+)${
            my ($type, $name) = ~<<$/;
            my $init = Noop;
            my $var = Var.new(:$name, :$type, :$*block, :$init);
            (%*scope{$name} = $var).declare;
        })
        | (:s (int) (\w+) '=' (\d+)${
            my ($type, $name, $value) = $/>>.Str;
            my $init = const(iv($value));
            my $var = Var.new(:$name, :$type, :$*block, :$init);
            (%*scope{$name} = $var).declare;
        })
        | (:s next (\w+)$ {is-label ~$0}{
            put "    goto \@.{lookup(~$0).bra}";
        })
        | (:s next (\w+) {is-label ~$0} if <expression>${
            put "    if_i {@*made[0].eval} \@.{lookup(~$0).bra}";
            @*made = ();
        })
        | (:s break (\w+) {is-label ~$0} unless <expression>${
            put "    unless_i {@*made[0].eval} \@.{lookup(~$0).ket}";
            @*made = ();
        })
        | (:s (@ops) <expression>**{OPS{$0}.arity}%[<.ws>?','<.ws>?]${
            put OPS{~$0}.eval(~$0, @*made);
            @*made = ();
        })
        | (:s (@types) (\w+) '=' (@ops)<?{OPS{$2}.arity-1 == 0}>${
            my ($type, $name, $op) = ~<<$/;
            my $init = Noop;
            my $var = Var.new(:$name, :$type, :$*block, :$init);
            (%*scope{$name} = $var).declare;
            @*made = $var;
            put OPS{$op}.eval($op, @*made);
            @*made = ();
        })
        | (:s (@types) (\w+) '=' (@ops)
                <expression>**{OPS{$2}.arity-1}%[<.ws>?','<.ws>?]${
            my ($type, $name, $op) = ~<<$/[^3];
            my $init = Noop;
            my $var = Var.new(:$name, :$type, :$*block, :$init);
            (%*scope{$name} = $var).declare;
            unshift @*made, $var;
            put OPS{$op}.eval($op, @*made);
            @*made = ();
        })
        | (:s (\w+) '=' <?{ lookup(~$0) ~~ Var }>(@ops)
                <expression>**{OPS{$1}.arity-1}%[<.ws>?','<.ws>?]${
            my ($varname, $op) = ~<<$/;
            @*made.unshift(lookup($varname));
            put OPS{$op}.eval($op, @*made);
            @*made = ();
        })
        | (:s (@multiops) <expression>*%[<.ws>?','<.ws>?]${
            put find_multi(~$0, argsig(@*made)).eval(~$0, @*made);
            @*made = ();
        })
        || {bailout}
    ]/ }

    bailout 'unclosed block';
}

class Op {
    has @.signature;
    has $.suffix;
    method suffix { $!suffix ?? "_{$!suffix}" !! '' }
    method arity { +@!signature }
    method pair { $.parsig => self }
    method parsig { @!signature.join }
    method eval($op, *@args) {
        my $i = 0;
        "    {$op}{$.suffix}" ~ @*made.map: -> $arg {
            ' ' ~ do given @!signature[$i++] {
                when any <i s o> { $arg.eval }
                when any <I S O> { $arg.promote.eval }
                default { die "panic: unexpected parameter sig '$_'" }
            }
        }
    }
}

class Block {
    has $.name;
    has $.id;
    has %.temps;
    method type { 'block' }
    method bra { "bra{$!id}_{$!name}" }
    method ket { "ket{$!id}_{$!name}" }
}

role Alias {
    has $.type;
    has $.block;
    has $.init;
    has $!declared;
    method longname { ... }
    method sig { uc sig $!type }
    method declare {
        $!declared = True;
        put "    .local[{$.type}] {$.longname}";
        .put with $!init.eval("\@{$.longname}");
    }
    method eval {
        self.declare unless $!declared;
        "\@{$.longname}";
    }
}

class Var does Alias {
    has $.name;
    method longname { "var{$!block.id}_{$!name}" }
    method promote { self }
}

class Tmp does Alias {
    has $.id;
    submethod TWEAK { $!id = $!block.temps{$!type}++ }
    method longname { "tmp{$!block.id}_{sig $.type}{$!id}" }
    method promote { self }
}

role Value {
    method type { ... }
    method sig { sig self.type }
    method eval { ... }
    method promote { Tmp.new(:$.type, :$*block, init => const(self)) }
}

class IVal does Value {
    has $.i;
    method type { 'int' }
    method eval { "$!i" }
}

class SVal does Value {
    has $.s;
    method type { 'str' }
    method eval { "'{$.enc}'" }
    sub enc($_) {
        when ^0x100 { .fmt("\\%02X") }
        when ^0x10000 { .fmt("\\u%04X") }
        when ^0x110000 { .fmt("\\U%06X") }
    }
    method enc { $!s.subst(:g, /\'|\v/, { .Str.NFC.map(&enc).join }) }
}

class Noop {
    method eval($target) {}
}

class Const {
    has $.value;
    method eval($target) {
        "    const_{extsig $!value.type} {$target} {$!value.eval}";
    }
}

class Cast {
    has $.expr;
    has $.type;
    method sig { uc sig $!type }
    method promote { Tmp.new(:$!type, :$*block, init => self) }
    method eval($target) {
        "    coerce_{sig $!expr.type}{sig $!type} {$target} {$!expr.eval}";
    }
}

sub capture-out(&block) {
    my $stdout = $*OUT;
    my @out;

    temp $*OUT = %*ENV<MOARTL_ECHO> === '1'
        ?? class { method print($_) { @out.push($_) } }
        !! class { method print($_) { $stdout.print($_); @out.push($_) } }

    block;
    @out.join;
}

sub load_moaras {
    use nqp;
    once {
        my $fh := nqp::open($?FILE.subst(/moartl0$/, 'moaras'), 'r');
        my $code := nqp::readallfh($fh);
        nqp::closefh($fh);
        nqp::loadbytecode('nqp.moarvm');
        nqp::getcomp('nqp').eval($code, :encoding<utf8>);
    }
}

sub eval_asm($asm) {
    use nqp;
    load_moaras;
    nqp::gethllsym('nqp', 'moaras::eval')($asm);
}

sub compile_asm($asm, $dest) {
    use nqp;
    load_moaras;
    nqp::gethllsym('nqp', 'moaras::compile')($asm, $dest);
}

proto MAIN(|) {
    CATCH {
        put ".abort {.^name}";
        when MoarTLException { note .message }
        default { note $_ }
        exit 1;
    }

    {*}
}

multi MAIN(*@src where ?*) {
    .&parse for @src;
    put '.done';
}

multi MAIN(Str $script, Bool :$run!, *@args) {
    eval_asm(capture-out({ parse $script }))(|@args);
}

multi MAIN(Str $src, Str $dest = $src.subst(/'.tiny'?$/, '.moarvm'),
        Bool :$compile!) {
    compile_asm(capture-out({ parse $src }), $dest);
}
