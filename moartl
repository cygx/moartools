#!/usr/bin/env perl6
# Copyright 2016 cygx <cygx@cpan.org>
# Distributed under the Boost Software License, Version 1.0

use v6;

my @ops = <dec exit say>;

class Op {
    has @.signature;
    has $.suffix;
    method suffix { $!suffix ?? "_{$!suffix}" !! '' }
    method arity { +@!signature }
    method eval($op, *@args) {
        my $i = 0;
        "    {$op}{$.suffix}" ~ @*made.map: -> $arg {
            ' ' ~ do given @!signature[$i++] {
                when 'I' { $arg.reg.eval }
                when 'S' { $arg.reg.eval }
            }
        }
    }
}

sub op(*@signature, :$suffix) {
    Op.new(:@signature, :$suffix);
}

my constant OPS = {
    dec => op(<I>, :suffix<i>),
    exit => op(<I>),
    say => op(<S>),
}

my $lines;
my $line;
my $n;

my @scopes;
my $blocks;

class X::MoarTL::Syntax is Exception {
    has $.msg;
    has $.n;
    has $.line;
    method new($msg) { self.bless(:$msg, :$n, :$line) }
    method message { "syntax error: $!msg\n[$!n] $!line" }
}

sub parse { ... }

proto MAIN(|) {
    CATCH {
        put ".abort {.^name}";
        when X::MoarTL::Syntax { note .message }
        default { note $_ }
        exit 1;
    }

    {*}

    put '.done';
}

multi MAIN(Str $src) { parse $src }
multi MAIN(*@src where $_ > 1) { .&parse for @src }

class Block { ... }
class Var { ... }
class IVal { ... }
class SVal { ... }

sub bailout($msg = '?') is hidden-from-backtrace {
    die X::MoarTL::Syntax.new($msg);
}

sub next-line {
    my $next := $lines.pull-one;
    return $next if $next =:= IterationEnd;
    ++$n;
    $line = $next.trim;
}

sub lookup($name) {
    for @scopes {
        return .{$name}
            if .{$name}:exists;
    }

    Nil;
}

sub block($name) { ... }

sub parse($src --> Nil) {
    put ".file $src";
    put ".hll tiny";

    my %*scope;

    $n = 0;
    $lines := $src.IO.lines(:close).iterator();
    @scopes := [ %*scope ];

    while ($_ := next-line) !=:= IterationEnd { /^[
        || [\#|$]
        || (:s fn (\w+)${ put ".frame $0" })
        || (:s fn (\w+)'()' '{'${
            my $name = ~$0;
            put ".frame $name";
            $blocks = 0;
            block $name;
        })
        || {bailout}
    ]/ }
}

sub iv(Int() $i) { IVal.new(:$i) }
sub sv(Str() $s) { SVal.new(:$s) }

my token expression {
    || ((\w+) <?{ lookup(~$0) ~~ Var }> { push @*made, lookup(~$0) })
    || ((\d+) { push @*made, iv(~$0) })
    || ("'" (<-[']>*) "'" { push @*made, sv(~$0) })
}

sub block($name) {
    my %*scope;
    my $*block = Block.new(:$name, id => $blocks++);
    %*scope{$name} = $*block;
    @scopes.unshift(%*scope);
    LEAVE @scopes.shift;

    put ".{$*block.bra}:";

    my @*made;
    while ($_ := next-line) !=:= IterationEnd { /^[
        | [\#|$]
        | (:s '.'(\w+) '{'${ block ~$0 })
        | ('}' ${
            put ".{$*block.ket}:";
            return;
        })
        | (:s (int) (\w+) '=' (\d+)${
            my ($type, $name, $value) = $/>>.Str;
            my $var = Var.new(:$name, :$type, :$*block);
            %*scope{$name} = $var;
            put "   .const[{$type}] {$var.longname} $value";
        })
        | (:s next (\w+) if <expression>${
            put "    if_i {@*made[0].eval} \@.{$*block.bra}";
            @*made = ();
        })
        | (:s (@ops) <expression>**{OPS{$0}.arity}%[<.ws>?','<.ws>?]${
            put OPS{~$0}.eval(~$0, @*made);
            @*made = ();
        })
        || {bailout}
    ]/ }

    bailout 'unclosed block';
}

sub suffix($_) {
    when 'int' { 'i' }
    when 'str' { 's' }
}

class Block {
    has $.name;
    has $.id;
    has %.temps;
    method type { 'block' }
    method bra { "bra{$!id}_{$!name}" }
    method ket { "ket{$!id}_{$!name}" }
}

class Var {
    has $.name;
    has $.type;
    has $.block;
    method longname { "var{$!block.id}_{$!name}" }
    method eval { "\@{$.longname}" }
    method reg { self }
}

class Tmp {
    has $.value;
    has $.block;
    has $.id;
    submethod TWEAK { $!id = $!block.temps{$!value.type}++ }
    method type { $!value.type }
    method longname { "tmp{$!block.id}_{suffix $.type}{$!id}" }
    method eval {
        put "    .const[{$.type}] {$.longname} {$!value.eval}";
        "\@{$.longname}";
    }
}

class IVal {
    has $.i;
    method type { 'int' }
    method reg { Tmp.new(value => self, :$*block) }
    method eval { "$!i" }
}

class SVal {
    has $.s;
    sub enc($_) {
        when ^0x100 { .fmt("\\%02X") }
        when ^0x10000 { .fmt("\\u%04X") }
        when ^0x110000 { .fmt("\\U%06X") }
    }
    method enc { $!s.subst(:g, /\'|\v/, { .Str.NFC.map(&enc).join }) }
    method type { 'str' }
    method reg { Tmp.new(value => self, :$*block) }
    method eval { "'{$.enc}'" }
}
