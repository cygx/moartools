#!/usr/bin/env perl6
# Copyright 2016 cygx <cygx@cpan.org>
# Distributed under the Boost Software License, Version 1.0

use v6;

my $lines;
my $line;
my $n;

my @scopes;
my $blocks;

class X::MoarTL::Syntax is Exception {
    has $.msg;
    has $.n;
    has $.line;
    method new($msg) { self.bless(:$msg, :$n, :$line) }
    method message { "syntax error: $!msg\n[$!n] $!line" }
}

sub parse { ... }

multi MAIN(Str $src) {
    parse $src.IO;
    CATCH {
        put "#.error {.^name}";
        when X::MoarTL::Syntax { note .message }
        default { note $_ }
        exit 1;
    }
}

multi MAIN(*@src where $_ > 1) {
    for @src {
        put "#.file $_";
        MAIN $_;
        print "\n";
    }
}

class Block { ... }
class Var { ... }

sub bailout($msg = '?') is hidden-from-backtrace {
    die X::MoarTL::Syntax.new($msg);
}

sub next-line {
    my $next := $lines.pull-one;
    return $next if $next =:= IterationEnd;
    ++$n;
    $line = $next.trim;
}

sub lookup($name) {
    for @scopes {
        return .{$name}
            if .{$name}:exists;
    }

    Nil;
}

sub block($name) { ... }

sub parse($src --> Nil) {
    put ".hll tiny";

    my %*scope;

    $n = 0;
    $lines := $src.lines(:close).iterator();
    @scopes := [ %*scope ];

    while ($_ := next-line) !=:= IterationEnd { /^[
        || [\#|$]
        || (:s fn (\w+)${ put ".frame $0" })
        || (:s fn (\w+)'()' '{'${
            my $name = ~$0;
            put ".frame $name";
            $blocks = 0;
            block $name;
        })
        || {bailout}
    ]/ }
}

my token expression($made is rw) {
    || ((\w+) <?{ lookup(~$0) ~~ Var }> ${ $made = lookup(~$0) })
}

sub block($name) {
    my %*scope;
    my $*block = Block.new(:$name, id => $blocks++);
    %*scope{$name} = $*block;
    @scopes.unshift(%*scope);
    LEAVE @scopes.shift;

    put ".{$*block.bra}:";

    my $made;
    while ($_ := next-line) !=:= IterationEnd { /^[
        | [\#|$]
        | (:s '.'(\w+) '{'${ block ~$0 })
        | ('}' ${
            put ".{$*block.ket}:";
            return;
        })
        | (:s (int) (\w+) '=' (\d+)${
            my ($type, $name, $value) = $/>>.Str;
            my $var = Var.new(:$name, :$type, :$*block);
            %*scope{$name} = $var;
            put "   .const[{$type}] {$var.longname} $value";
        })
        | (:s next (\w+) if <expression($made)>${
            put "    if_i {$made.eval} \@.{$*block.bra}";
        })
        | (:s (dec) <expression($made)>${
            my $op = ~$0;
            my $suffix = { int => 'i' }.{$made.type} // bailout $made.type;
            put "    {$op}_{$suffix} {$made.eval}";
        })
        || {bailout}
    ]/ }

    bailout 'unclosed block';
}

class Block {
    has $.name;
    has $.id;
    method type { 'block' }
    method bra { "bra{$!id}_{$!name}" }
    method ket { "ket{$!id}_{$!name}" }
}

class Var {
    has $.name;
    has $.type;
    has $.block;
    method longname { "var{$!block.id}_{$!name}" }
    method eval { "\@{self.longname}" }
}
